CLASS zcl_ai_node_llm_planner DEFINITION
  PUBLIC
  INHERITING FROM zcl_ai_node_base
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES zif_ai_tool_catalog_aware.

    METHODS constructor
      IMPORTING
        name       TYPE string.
        " llm_client generated by constructor
*        llm_client TYPE REF TO zcl_ai_llm_client OPTIONAL.

    METHODS zif_ai_node~get_configuration REDEFINITION.
    METHODS zif_ai_node~set_configuration REDEFINITION.

  PROTECTED SECTION.
    DATA llm_client TYPE REF TO zcl_ai_llm_client.

    " Catalog injected by builder (all tools known to agent)
    DATA tool_catalog TYPE zif_ai_types=>th_tool_registry_map.

    METHODS do_execute REDEFINITION.

  PRIVATE SECTION.
    "structure for easily transform the configuration to json
    TYPES: BEGIN OF ts_llm_planner_node_config,
             name TYPE string,
           END OF ts_llm_planner_node_config.

    METHODS catalog_to_text
      RETURNING VALUE(text) TYPE string.

    METHODS pick_tool_heuristic
      IMPORTING
        state            TYPE zif_ai_types=>ts_graph_state
      RETURNING
        VALUE(tool_name) TYPE string.

    METHODS should_request_hitl
      IMPORTING
        state             TYPE zif_ai_types=>ts_graph_state
      RETURNING
        VALUE(needs_hitl) TYPE abap_bool.
ENDCLASS.



CLASS zcl_ai_node_llm_planner IMPLEMENTATION.

  METHOD constructor.
    super->constructor( node_name = name ).
    me->llm_client = new zcl_ai_llm_client( ).
  ENDMETHOD.

  METHOD zif_ai_tool_catalog_aware~set_tool_catalog.
    me->tool_catalog = tool_catalog.
  ENDMETHOD.

  METHOD catalog_to_text.
    text = ``.
    LOOP AT tool_catalog INTO DATA(entry).
      text = text &&
             | - { entry-tool_name }: { entry-tool_description }| &&
             cl_abap_char_utilities=>newline.
    ENDLOOP.
  ENDMETHOD.

  METHOD pick_tool_heuristic.
    " Simple deterministic planner:
    " - If user mentions 'risk' -> try risk_check_tool if exists
    " - Else if user mentions 'table' or an SAP table name-like token -> try table_info_tool if exists
    " - Else pick first tool from catalog (if any)

    DATA messages_upper TYPE string.
    "messages_upper = to_upper( state-messages ).

    messages_upper = zcl_ai_utils=>messages_to_string( state-messages ).
    TRANSLATE messages_upper TO UPPER CASE.

    " TODO: Use LLM to determine tool to use
    " TODO: Use LLM to determine tool parameters to use

    " If user mentions 'risk' -> try risk_check_tool if exists
    IF messages_upper CS 'RISK'.
      IF line_exists( tool_catalog[ tool_name = 'risk_check_tool' ] ).
        tool_name = 'risk_check_tool'.
        RETURN.
      ENDIF.
    ENDIF.

    IF messages_upper CS 'TABLE' OR messages_upper CS 'VBAK'.
      IF line_exists( tool_catalog[ tool_name = 'table_info_tool' ] ).
        tool_name = 'table_info_tool'.
        RETURN.
      ENDIF.
    ENDIF.

    LOOP AT tool_catalog INTO DATA(entry).
      tool_name = entry-tool_name.
      EXIT.
    ENDLOOP.
  ENDMETHOD.

  METHOD do_execute.
    DATA(logger) = zcl_abapchain_logger=>get_instance( ).

    TRY.
        logger->log_node(
          node_name = me->node_name
          node_id   = me->node_id
          message   = |Planner step. Catalog tools={ lines( tool_catalog ) }.|
          severity  = if_bali_constants=>c_severity_status ).
      CATCH cx_root.
    ENDTRY.

    " If no catalog -> cannot plan tool usage
    IF tool_catalog IS INITIAL.
      APPEND VALUE #( role = zif_ai_types=>gc_role_error content = |[Planner { node_name }] No tool catalog injected. Ending.| ) TO state-messages.
      state-branch_label = 'END'.
      RETURN.
    ENDIF.

    " If a tool was just executed, decide whether to finish.
    " Minimal policy: after one tool call, end the run (for now).
*    IF state-last_tool_name IS NOT INITIAL.
*      state-messages = state-messages &&
*        cl_abap_char_utilities=>newline &&
*        |[Planner { name }] Tool "{ state-last_tool_name }" already used. Ending.|.
*
*      state-branch_label = 'END'.
*      RETURN.
*    ENDIF.

    " Presentation policy: do 2 tools, then FINAL
    IF state-last_tool_name = 'table_info'.
      state-branch_label   = 'TOOL'.
      state-last_tool_name = 'risk_check'.
      APPEND VALUE #( role = zif_ai_types=>gc_role_tool content = |[Planner { node_name }] Next: tool "risk_check".| ) TO state-messages.

      RETURN.
    ELSEIF state-last_tool_name = 'risk_check'.

      " After risk check, require human approval (HITL) before final
      state-branch_label = 'HITL'.



      " (Optional) Pre-fill HITL prompt data in state so HumanInputNode can just persist it
      state-hitl_topic           = 'ABAPCHAIN'.
      state-hitl_reason          = 'Risk check completed; approval required to continue.'.
      state-hitl_prompt          = 'Approve continuing with the operation?'.
      state-hitl_primary_field   = 'approved'.
      state-hitl_response_schema = '{ "type":"object", "properties": { "approved": { "type":"boolean" } }, "required": ["approved"] }'.

      APPEND VALUE #( role = zif_ai_types=>gc_role_tool content = |[Planner { node_name }] Risk check done. Routing to HITL approval.| ) TO state-messages.

*
*    state-branch_label = 'FINAL'.
*      state-messages = state-messages && cl_abap_char_utilities=>newline &&
*        |[Planner { name }] Done with tools. Routing to FINAL.|.

      RETURN.
    ENDIF.


    " Decide next tool:
    DATA(next_tool) = pick_tool_heuristic( state ).

    IF next_tool IS INITIAL.
      APPEND VALUE #( role = zif_ai_types=>gc_role_error content = |[Planner { node_name }] Could not pick a tool. Ending.| ) TO state-messages.

      state-branch_label = 'END'.
      RETURN.
    ENDIF.

    " Route to Tool Executor node
    state-branch_label   = 'TOOL'.
    state-last_tool_name = next_tool.

    APPEND VALUE #( role = zif_ai_types=>gc_role_tool content =      |[Planner { node_name }] Request tool "{ next_tool }".| ) TO state-messages.

    TRY.
        logger->log_node(
          node_name = me->node_name
          node_id   = me->node_id
          message   = |Route TOOL. requested="{ next_tool }".|
          severity  = if_bali_constants=>c_severity_information ).
      CATCH cx_root.
    ENDTRY.

  ENDMETHOD.

  METHOD should_request_hitl.
    needs_hitl = abap_false.

    DATA text TYPE string.
    text = zcl_ai_utils=>messages_to_string( state-messages ).
    TRANSLATE text TO UPPER CASE.

    " Heuristic triggers
    IF text CS 'APPROVE'
       OR text CS 'APPROVAL'
       OR text CS 'HUMAN'
       OR text CS 'CONFIRM'
       OR text CS 'PROCEED'
       OR text CS 'RISK'.
      needs_hitl = abap_true.
      RETURN.
    ENDIF.
  ENDMETHOD.

  METHOD zif_ai_node~get_configuration.
    DATA(config) = VALUE ts_llm_planner_node_config( name = me->node_name ).
    configuration = xco_cp_json=>data->from_abap( config )->to_string( ).
  ENDMETHOD.

  METHOD zif_ai_node~set_configuration.
    DATA(config) = VALUE ts_llm_planner_node_config( ).
    xco_cp_json=>data->from_string( configuration )->write_to( REF #( config ) ).
    me->node_name = config-name.
  ENDMETHOD.

ENDCLASS.
